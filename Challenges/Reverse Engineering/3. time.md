

# 3. time

## Solution:

When the program is run, we are asked to enter a number. 

```
cookorcooked@ubuntu25:~/Desktop/Curated/time$ ./time
Welcome to the number guessing game!
I'm thinking of a number. Can you guess it?
Guess right and you get a flag!
Enter your number: 123456
Your guess was 123456.
Looking for 1917909052.
Sorry. Try again, wrong guess!
cookorcooked@ubuntu25:~/Desktop/Curated/time$ ./time
Welcome to the number guessing game!
I'm thinking of a number. Can you guess it?
Guess right and you get a flag!
Enter your number: 1917909052
Your guess was 1917909052.
Looking for 1022262476.
Sorry. Try again, wrong guess!

```
We can observe that the number is different everytime we run the program. Hence we need to be dynamic with our apporach and observe the program while it runs.

We can use gdb for this.

Using gdb, I got the assembly code of the main function,

```
(gdb) disas main
Dump of assembler code for function main:
   0x000000000040092b <+0>:	push   %rbp
   0x000000000040092c <+1>:	mov    %rsp,%rbp
   0x000000000040092f <+4>:	sub    $0x20,%rsp
   0x0000000000400933 <+8>:	mov    %edi,-0x14(%rbp)
   0x0000000000400936 <+11>:	mov    %rsi,-0x20(%rbp)
   0x000000000040093a <+15>:	mov    %fs:0x28,%rax
   0x0000000000400943 <+24>:	mov    %rax,-0x8(%rbp)
   0x0000000000400947 <+28>:	xor    %eax,%eax
   0x0000000000400949 <+30>:	mov    $0x0,%edi
   0x000000000040094e <+35>:	call   0x400750 <time@plt>
   0x0000000000400953 <+40>:	mov    %eax,%edi
   0x0000000000400955 <+42>:	call   0x400730 <srand@plt>
   0x000000000040095a <+47>:	call   0x400790 <rand@plt>
   0x000000000040095f <+52>:	mov    %eax,-0xc(%rbp)
   0x0000000000400962 <+55>:	lea    0x1c7(%rip),%rdi        # 0x400b30
   0x0000000000400969 <+62>:	call   0x4006e0 <puts@plt>
   0x000000000040096e <+67>:	lea    0x1e3(%rip),%rdi        # 0x400b58
   0x0000000000400975 <+74>:	call   0x4006e0 <puts@plt>
   0x000000000040097a <+79>:	lea    0x207(%rip),%rdi        # 0x400b88
   0x0000000000400981 <+86>:	call   0x4006e0 <puts@plt>
   0x0000000000400986 <+91>:	lea    0x21b(%rip),%rdi        # 0x400ba8
   0x000000000040098d <+98>:	mov    $0x0,%eax
```

We can observe that the program uses the function time,srand and rand to generate the number needed.

When we see the remaining main code, we notice this -

```
   0x00000000004009a6 <+123>:	lea    -0x10(%rbp),%rax
   0x00000000004009aa <+127>:	mov    %rax,%rsi
   0x00000000004009ad <+130>:	lea    0x208(%rip),%rdi        # 0x400bbc
   0x00000000004009b4 <+137>:	mov    $0x0,%eax
   0x00000000004009b9 <+142>:	call   0x400780 <__isoc99_scanf@plt>
```
So if we break the program right at this `0x00000000004009b9 <+142>:	call   0x400780 <__isoc99_scanf@plt>` line when the scanf function is called, and inspect the memory, we can find the number needed.

From the disassembled code we know the address of where the randomly generated number is stored.

Now we just need to use gdb to solve the challenge.

```
(gdb) break *0x00000000004009b4
Breakpoint 1 at 0x4009b4
(gdb) run
Starting program: /home/cookorcooked/Desktop/Curated/time/time 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to the number guessing game!
I'm thinking of a number. Can you guess it?
Guess right and you get a flag!
Enter your number: 
Breakpoint 1, 0x00000000004009b4 in main ()
(gdb) print *(int*)($rbp - 0xc)
$1 = 1310357320
(gdb) continue
Continuing.
1310357320
Your guess was 1310357320.
Looking for 1310357320.
You won. Guess was right! Here's your flag:
Flag file not found!  Contact an H3 admin for assistance.
```


## Flag:
```
NONE
```

## Concepts learnt:

- Learnt how to manipulate a program and inspect memory while it runs using gdb.

## Notes:

- NONE
  
## Resources:

- NONE

***
