
# 5. Dusty

# i) dust_noob

## Solution:

The main function doesn't have much other than setting up Rust and then goes to the actual block of code that is in shinyclean::main()

The shinyclean::main() fucntion declares two arrays of size 23, and fills one of them with hard coded data.
There is a loop that just XORs the first array's data and stores it into the other array.

The flag can be found by just decoding these XOR operations.

I wrote a python script to do this,

```
data = [
    0x7b, 0x5e, 0x48, 0x58, 0x7c, 0x6b, 0x79, 0x44,
    0x79, 0x6d, 0x0c, 0x0c, 0x60, 0x7c, 0x0b, 0x6d,
    0x60, 0x68, 0x0b, 0x0a, 0x77, 0x1e, 0x42
]

decoded = "".join(chr(b ^ 0x3f) for b in data)
print(decoded)
```

Executing this script gives me the flag. 

```
cookorcooked@ubuntu25:~/Desktop/Curated/Dusty$ python3 decodeflag.py
DawgCTF{FR33_C4R_W45H!}
```


## Flag:

```
DawgCTF{FR33_C4R_W45H!}
```

## Concepts learnt:

- Learnt the basics of how Rust works and how it's pseudo code looks in ghidra.
- Learnt how to reverse a XOR using very basic python. 

## Notes:

- NONE
  
## Resources:

- NONE

***

# ii) dust_intermediate

## Solution:

Again, the primary chunk of code is in shinyclean2::main().

Looking at the code we can see that the program converts our input strings into bytes and sends these bytes into a different thread using an mpsc channel, the bytes are then transformed and stored into a vector in main which is then lastly compared to a hardcoded array.

We can easily find what the byte sequence is after the transformations, 
```
EA D9 31 22 D3 E6 97 70 
16 A2 A8 1B 61 FC 76 68 
7B AB B8 27 96
```
The transformations happen in `shinyclean2::a` as seen here-

```
local_121 += local_11b;
output = DAT_00161298[local_121];
```
This is where the main transformation happens. The `shinyclean2::a` function takes each byte, and adds it to a rolling key starting from `0x75`, then it uses this as index for a sort of lookup table located at `DAT_00161298`.
And sends the output back using an mpsc channel. This process happens 21 times and the final flag is produced. 

We can now write a simple python script having the values at `DAT_00161298` to get the flag.

```
lookup=[0x9f,0xd2,0xd6,0xa8,0x99,0x76,0xb8,0x75,0xe2,0x0e,0x50,0x67,0xc9,0x3a,0xa0,0xb5,0x15,0xee,0x59,0xbe,0x7d,0xa3,0xfb,0x51,0xdf,0x7c,0xd9,0x0d,0xe7,0x2d,0xad,0x28,0xed,0xdc,0x3d,0x14,0x13,0x79,0xaf,0x27,0xd1,0xd5,0xa1,0xf9,0x37,0xc0,0xef,0x25,0x38,0x77,0xff,0x1b,0x40,0x60,0x8f,0x45,0x6f,0x08,0x6d,0xd3,0x35,0x3f,0xb4,0x2f,0xd7,0x34,0x5f,0x05,0xbb,0x11,0x3e,0x84,0x5b,0x00,0xf5,0x29,0x36,0x2c,0x63,0x2b,0x70,0x68,0x02,0xae,0xc4,0x95,0x10,0x89,0xb0,0x2e,0x55,0xcc,0xbc,0x80,0xa6,0xf3,0xd8,0x5a,0x62,0x61,0x9a,0xa5,0xfe,0x3c,0xb2,0x7e,0xbf,0xa7,0xeb,0x41,0x7a,0xfa,0x53,0x47,0xdd,0x6b,0x54,0x65,0x9d,0x0b,0x73,0x94,0x81,0x1d,0x4c,0xac,0x46,0xde,0x43,0x9c,0xfd,0x7f,0x6a,0x7b,0x07,0x01,0xf7,0xe5,0xb3,0xcd,0x1f,0xc7,0x58,0xe6,0x4d,0x31,0x4a,0xd0,0x98,0x93,0x20,0xc5,0x1e,0x6c,0x8c,0x09,0x78,0xbd,0x03,0x23,0x82,0xdb,0x12,0x16,0x96,0xc8,0xce,0xf4,0xe0,0xa4,0x04,0xca,0x49,0x87,0xc2,0x32,0x6e,0xf1,0x39,0x1c,0x85,0x5e,0x92,0xf8,0xab,0xea,0x8d,0xc1,0x86,0x17,0x8a,0xb1,0xf2,0x4f,0xfc,0xe1,0xcb,0xb6,0x42,0xba,0xa9,0x88,0x66,0x4e,0x18,0xf6,0x64,0xaa,0x2a,0x8b,0xf0,0xa2,0xec,0x97,0x5c,0xe3,0xcf,0x91,0x0c,0x1a,0x30,0x5d,0x69,0x56,0xe4,0x9b,0x0f,0x90,0xc6,0x72,0x48,0x06,0x33,0x9e,0x0a,0x83,0x8e,0x52,0x19,0xe8,0x44,0xda,0x26,0xd4,0x3b,0x4b,0x74,0x24,0x22,0xb7,0xc3,0x21,0xe9,0xb9,0x71,0x57]

exp=[0xea,0xd9,0x31,0x22,0xd3,0xe6,0x97,0x70,0x16,0xa2,0xa8,0x1b,0x61,0xfc,0x76,0x68,0x7b,0xab,0xb8,0x27,0x96]

rev={}
for i in range(len(lookup)):
    rev[lookup[i]]=i

x=0x75
o=[]
for e in exp:
    j=rev[e]
    o.append((j-x)&0xff)
    x=j

print(bytes(o).decode())

```

Executing this script we get the final flag.

```
cookorcooked@ubuntu25:~/Desktop/Curated/Dusty$ python3 solve_intermediate.py
DawgCTF{S0000_CL43N!}
```



## Flag:

```
DawgCTF{S0000_CL43N!}
```

## Concepts learnt:

- Lernt more about Rust and about mpsc channels and threads.
- Learnt how to better understand code and reverse it.

## Notes:

- NONE
  
## Resources:

- NONE

***


# iii) dust_pro

## Solution:

Again the actual code is not in main but in shinyclean2::main().

The first thing we can see is an array `local_1b1` with 25 characters.
The program reads an integer value which is then converted into 4 bytes using `u32::to_ne_bytes()`.

There is a loop that modifies the original array, analzying it we can see that the output bytes would be

`output[i] = base [i] XOR key[i % 4]`

Now since we know the first 8 ASCII values from our flag format `DawgCTF{`, we can find the key, and hence XOR all the bytes to get our flag.

This can be done using a simple python script -
```
base=[0xcf,0x09,0x1e,0xb3,0xc8,0x3c,0x2f,0xaf,0xbf,0x24,0x25,0x8b,0xd9,0x3d,0x5c,0xe3,0xd4,0x26,0x59,0x8b,0xc8,0x5c,0x3b,0xf5,0xf6]
key=[0x8b,0x68,0x69,0xd4]
x=[]
for i in range(len(base)):
    x.append(base[i]^key[i%4])
print(bytes(x).decode())
print(int.from_bytes(bytes(key),"little"))

```
Executing this we get the flag as well as the expected input.

```
cookorcooked@ubuntu25:~/Desktop/Curated/Dusty$ python3 solve_pro.py
DawgCTF{4LL_RU57_N0_C4R!}
3563677835
cookorcooked@ubuntu25:~/Desktop/Curated/Dusty$ ./dust_pro
Enter your ShinyCleanâ„¢ code below:
3563677835
Congratulations! You win a DawgCTF{4LL_RU57_N0_C4R!}

```


## Flag:

```
DawgCTF{4LL_RU57_N0_C4R!}
```

## Concepts learnt:

- Learnt how to analyze and reverse complex code.

## Notes:

- NONE
  
## Resources:

- NONE

***

